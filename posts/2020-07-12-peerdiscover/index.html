<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>üëì Peer Discovery over UDP</title><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:image" content><link rel=canonical href=https://teukka.tech/posts/2020-07-12-peerdiscover/><meta property="og:title" content="Peer Discover over UDP"><meta property="og:description" content="Find and connect to other machines on your local network via UDP"><meta property="og:type" content="article"><meta property="og:url" content="https://teukka.tech/posts/2020-07-12-peerdiscover/"><meta property="og:image" content="https://images.unsplash.com/photo-1586307679625-79bf5a822584?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=700&q=80"><meta property="article:published_time" content="2020-07-12T00:00:00+00:00"><meta property="article:modified_time" content="2020-07-12T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://images.unsplash.com/photo-1586307679625-79bf5a822584?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=700&q=80"><meta name=twitter:title content="Peer Discover over UDP"><meta name=twitter:description content="Find and connect to other machines on your local network via UDP"><link href=https://teukka.techcss/fonts.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://teukka.techcss/main.css><link rel=stylesheet type=text/css href=https://teukka.techcss/dark.css media="(prefers-color-scheme: dark)"><script>if(window.location.host!=='teukka.tech')
window.goatcounter={no_onload:true};</script></head><body><div class=content><header><div class=main><a href=https://teukka.tech>Taylor Thompson's Blog</a></div><nav><a href=/>Home</a>
<a href=/posts>All posts</a>
<a href=/knowledgebase>Knowledge Base</a>
<a href=/tags>Tags</a></nav></header><main><article><div class=title><h1 class=title>Peer Discover over UDP</h1><div class=meta>Posted on Jul 12, 2020</div></div><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/nodejs>nodeJS</a></li><li><a href=/tags/rust>Rust</a></li><li><a href=/tags/systems-programming>systems programming</a></li></ul></nav></div><section class=body><h3 id=what-is-peer-discovery>What is Peer discovery</h3><p>Peer discovery allows you to discover other computers on the same subnet, intranet, or through the internet. Discovering peers directly removes the necessity of a centralized server architecture, reducing the number of network jumps your packets require to share information with each other. Peer discovery can be used in: discovering microservices in the same docker network or kubernetes cluster, file sharing (like airdrop and bittorrent), and peer to peer gaming. Eliminating a centralized communication server can reduce operating costs, improve communication times between clients, and lead to more robust services since there is no single point of failure. Taking advantage of the benefits listed above requires a decentralized architecture.</p><h3 id=multicast-groups>Multicast Groups</h3><p>Multicasting is one of the tools we can use in creating a decentralized system. Multicasting is the process where messages are sent to a group of participants on the network. Multicasting differs from Broadcasting by only sending data to a specified <em>group</em> of network nodes, whereas broadcasting sends data to all network nodes. Implementing multicasting incurs a distinct set of challenges compared to centralized architectures; consider the following listed by Microsoft&rsquo;s article about <a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc759719(v=ws.10)">IPV4 Multicasting</a>:</p><ul><li>Multicast traffic is sent to an ambiguous group destination.</li><li>Because group addresses represent different groups with different members, group addresses generally cannot be summarized in the IP multicast forwarding table.</li><li>The location of group members is not consistent, so the IP multicast forwarding table might need to be updated whenever a group member joins or leaves a multicast group. Multicast routing protocols update the IP multicast forwarding table.</li></ul><p>Because the challenges like those listed above, reasoning about multicast traffic requires different mental model than a traditional client-server architecture. A critical concept in multicasting the <em>multicast group</em>. A multicast group can be compared to a chat application: membership is dynamic; members can leave and join at will, group members can be located anywhere on a multicast enabled network (compared to a server with a static IP address), a host can be a member of as many multicast groups as desired. A multicast group <em>can</em> have a well known address, for example 224.0.0.1 is the multicast address for all hosts in the subnet.</p><p>Members of multicast groups listening for incoming traffic will first bind their UDP socket to an available interface and join the multicast group. After joining the group, this member can receive datagram packets on the bound interface without the other members of the group knowing it&rsquo;s specific IP address. A similar process goes for multicast group members sending data to the group. Senders will bind their UDP socket on an available interface and begin transmitting datagram packets to the multicast group address. Through the magic of multicasting, the sender does not require information other than the group address for their packets to reach group members who are listening for incoming data.</p><h3 id=diving-into-the-code>Diving into the code</h3><p>To start multicasting over UDP requires only a few lines of code. For this post, we&rsquo;ll create a small program which sends a username to members of a multicast group. First, we want to set up a listener for other peers sending data to the multicast group. To do this, we need to bind the UDP socket to an available interface and join the multicast group:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:red>use</span> std::net::{Ipv4Addr, SocketAddrV4, UdpSocket};

<span style=color:red>static</span> MULTI_CAST_ADDR: Ipv4Addr = Ipv4Addr::new(<span style=color:#f60>224</span>, <span style=color:#f60>0</span>, <span style=color:#f60>0</span>, <span style=color:#f60>1</span>);

<span style=color:red>pub</span> <span style=color:red>fn</span> <span style=color:#ff0>listen</span>() {
  <span style=color:red>let</span> socket_address: SocketAddrV4 = SocketAddrV4::new(Ipv4Addr::new(<span style=color:#f60>0</span>, <span style=color:#f60>0</span>, <span style=color:#f60>0</span>, <span style=color:#f60>0</span>), <span style=color:#f60>9778</span>);
  <span style=color:red>let</span> bind_addr = Ipv4Addr::new(<span style=color:#f60>0</span>, <span style=color:#f60>0</span>, <span style=color:#f60>0</span>, <span style=color:#f60>0</span>);
  <span style=color:red>let</span> socket = UdpSocket::bind(socket_address)?;
  println!(<span style=color:#87ceeb>&#34;Listening on: {}&#34;</span>, socket.local_addr().unwrap());
  socket.join_multicast_v4(&amp;MULTI_CAST_ADDR, &amp;bind_addr)?;
}
</code></pre></div><p>Notice we create a new IP address struct with the values, <code>0, 0, 0, 0</code>, which the equivalent of saying &ldquo;Any available IP interface&rdquo;.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:red>import</span> dgram from <span style=color:#87ceeb>&#34;dgram&#34;</span>;

<span style=color:red>const</span> MULTI_CAST_ADDR = <span style=color:#87ceeb>&#34;224.0.0.1&#34;</span>;

<span style=color:red>function</span> listen() {
  <span style=color:red>const</span> server = dgram.createSocket(<span style=color:#87ceeb>&#34;udp4&#34;</span>);
  server.bind(<span style=color:#f60>9778</span>, () =&gt; {
    server.addMembership(MULTI_CAST_ADDR);
  });
  server.on(<span style=color:#87ceeb>&#34;listening&#34;</span>, () =&gt; {
    <span style=color:red>const</span> address = server.address();
    console.log(<span style=color:#87ceeb>`Listening on: </span><span style=color:#87ceeb>${</span>address.address<span style=color:#87ceeb>}</span><span style=color:#87ceeb>:</span><span style=color:#87ceeb>${</span>address.port<span style=color:#87ceeb>}</span><span style=color:#87ceeb>`</span>);
  });
}
</code></pre></div><p><code>MULTI_CAST_ADDR</code> points an IP address, <code>224.0.0.1</code>, as stated earlier, this is the reserved multicast address for all systems on the current subnet. Since the code is listening for messages being sent to the multicast group, we need to <em>join</em> the group <em>in addition to</em> binding the socket on an available IP Interface. In contrast to a server listening to incoming HTTP connections, we not only bind our server to a local IP address and a port, but we also join a multicast group whose address is part of the subnet. Since we are binding the UDP server to a local address and port <em>and</em> joining the multicast group, it can receive data from a direct connection ( like HTTP ), <em>and</em> from the multicast group.</p><p>Now time for the logic for receiving the multicast group data. Luckily, whether the data coming from the multicast group or from a direct connection, the code the same.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:red>pub</span> <span style=color:red>fn</span> <span style=color:#ff0>listen</span>() -&gt; Result&lt;()&gt; {
    <span style=color:red>let</span> socket_address: SocketAddrV4 = SocketAddrV4::new(Ipv4Addr::new(<span style=color:#f60>0</span>, <span style=color:#f60>0</span>, <span style=color:#f60>0</span>, <span style=color:#f60>0</span>), <span style=color:#f60>9778</span>);
    <span style=color:red>let</span> bind_addr = Ipv4Addr::new(<span style=color:#f60>0</span>, <span style=color:#f60>0</span>, <span style=color:#f60>0</span>, <span style=color:#f60>0</span>);
    <span style=color:red>let</span> socket = UdpSocket::bind(socket_address)?;
    println!(<span style=color:#87ceeb>&#34;Listening on: {}&#34;</span>, socket.local_addr().unwrap());
    socket.join_multicast_v4(&amp;MULTI_CAST_ADDR, &amp;bind_addr)?;
    <span style=color:red>loop</span> {
        <span style=color:#0f0>// set up message buffer with size of 120 bytes
</span><span style=color:#0f0></span>        <span style=color:red>let</span> <span style=color:red>mut</span> buf = [<span style=color:#f60>0</span>; <span style=color:#f60>120</span>];
        <span style=color:red>let</span> (data, origin) = socket.recv_from(&amp;<span style=color:red>mut</span> buf)?;
        <span style=color:red>let</span> buf = &amp;<span style=color:red>mut</span> buf[..data];
        <span style=color:red>let</span> message = String::from_utf8(buf.to_vec()).unwrap();
        println!(<span style=color:#87ceeb>&#34;server got: {} from {}&#34;</span>, message, origin);
    }
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:red>function</span> listen() {
  <span style=color:red>const</span> server = dgram.createSocket(<span style=color:#87ceeb>&#34;udp4&#34;</span>);
  <span style=color:#0f0>// Listen for incoming messages
</span><span style=color:#0f0></span>  server.on(<span style=color:#87ceeb>&#34;message&#34;</span>, (msg, rinfo) =&gt; {
    console.log(<span style=color:#87ceeb>`server got: </span><span style=color:#87ceeb>${</span>msg<span style=color:#87ceeb>}</span><span style=color:#87ceeb> from </span><span style=color:#87ceeb>${</span>rinfo.address<span style=color:#87ceeb>}</span><span style=color:#87ceeb>:</span><span style=color:#87ceeb>${</span>rinfo.port<span style=color:#87ceeb>}</span><span style=color:#87ceeb>`</span>);
  });
  server.bind(<span style=color:#f60>9778</span>, (a) =&gt; {
    server.addMembership(MULTI_CAST_ADDR);
  });
  server.on(<span style=color:#87ceeb>&#34;listening&#34;</span>, () =&gt; {
    <span style=color:red>const</span> address = server.address();
    console.log(<span style=color:#87ceeb>`Listening on: </span><span style=color:#87ceeb>${</span>address.address<span style=color:#87ceeb>}</span><span style=color:#87ceeb>:</span><span style=color:#87ceeb>${</span>address.port<span style=color:#87ceeb>}</span><span style=color:#87ceeb>`</span>);
  });
}
</code></pre></div><p>After setting up logic for listening to incoming messages on the multicast group address, our basic server is done! Now we can create the function that will send packets to the multicast address:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:red>use</span> std::net::{Ipv4Addr, SocketAddrV4, UdpSocket};

<span style=color:red>static</span> MULTI_CAST_ADDR: Ipv4Addr = Ipv4Addr::new(<span style=color:#f60>224</span>, <span style=color:#f60>0</span>, <span style=color:#f60>0</span>, <span style=color:#f60>1</span>);

<span style=color:red>pub</span> <span style=color:red>fn</span> <span style=color:#ff0>cast</span>() -&gt; Result&lt;()&gt; {
    <span style=color:red>let</span> socket_address: SocketAddrV4 = SocketAddrV4::new(Ipv4Addr::new(<span style=color:#f60>0</span>, <span style=color:#f60>0</span>, <span style=color:#f60>0</span>, <span style=color:#f60>0</span>), <span style=color:#f60>0</span>);
    <span style=color:red>let</span> socket = UdpSocket::bind(socket_address)?;
    socket.connect(SocketAddrV4::new(MULTI_CAST_ADDR, <span style=color:#f60>9778</span>))?;
    <span style=color:#0f0>// Don&#39;t send messages to yourself.
</span><span style=color:#0f0></span>    <span style=color:#0f0>// In this case self discovery is for human developers, not machines.
</span><span style=color:#0f0></span>    socket.set_multicast_loop_v4(<span style=color:red>false</span>)?;
    <span style=color:red>let</span> data = String::from(<span style=color:#87ceeb>&#34;{\&#34;username\&#34;: \&#34;test\&#34;}&#34;</span>)
     <span style=color:red>loop</span> {
        socket.send(data.as_bytes())?;
        thread::sleep(time::Duration::from_secs(<span style=color:#f60>2</span>));
    }
    Ok(())
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:red>import</span> dgram from <span style=color:#87ceeb>&#34;dgram&#34;</span>;

<span style=color:red>const</span> MULTI_CAST_ADDR = <span style=color:#87ceeb>&#34;224.0.0.1&#34;</span>;

<span style=color:red>function</span> cast() {
  <span style=color:red>const</span> client = dgram.createSocket(<span style=color:#87ceeb>&#34;udp4&#34;</span>);
  setInterval(() =&gt; {
    <span style=color:red>const</span> message = Buffer.from(JSON.stringify({ username: <span style=color:#87ceeb>&#34;hackerman1337&#34;</span> }));
    client.send(message, <span style=color:#f60>9778</span>, MULTI_CAST_ADDR);
  }, <span style=color:#f60>2000</span>);
}
</code></pre></div><p>Unlike the <code>listen</code> function, when we are sending data to the multicast address, we don&rsquo;t need to join the multicast group. Since we are using UDP for peer discovery, we can fire and forget these messages from the <code>cast</code> function as there will be no response from the server.</p><p>To test our peer discovery functions, you need two computers connected to the same subnet, or two docker containers running in the same docker network, or a docker container and your computer. Note that while you don&rsquo;t need to expose docker ports in order for the program running on your computer to discover the program running in the docker container, you will need to expose ports in order for your container to discover the host machine. We also need to combine our two functions so that we are both broadcasting our presence and listening for peers.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:red>use</span> std::thread;

<span style=color:red>fn</span> <span style=color:#ff0>main</span>() {
  thread::spawn(||{
      listen();
    });
  cast();
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:red>import</span> cluster from <span style=color:#87ceeb>&#34;cluster&#34;</span>;

<span style=color:red>function</span> main() {
  <span style=color:red>if</span> (cluster.isMaster) {
    cluster.fork();
    listen();
  } <span style=color:red>else</span> <span style=color:red>if</span> (cluster.isWorker) {
    cast();
  }
}

main();
</code></pre></div><p>That&rsquo;s it! If you run the program on two different computers on the same subnet, or two docker containers in the same docker network, you can observe the peers are able to discover each other&rsquo;s username and IP Address. The final code output:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:red>use</span> std::net::{Ipv4Addr, SocketAddrV4, UdpSocket};
<span style=color:red>use</span> std::thread;

<span style=color:red>static</span> MULTI_CAST_ADDR: Ipv4Addr = Ipv4Addr::new(<span style=color:#f60>224</span>, <span style=color:#f60>0</span>, <span style=color:#f60>0</span>, <span style=color:#f60>1</span>);

<span style=color:red>pub</span> <span style=color:red>fn</span> <span style=color:#ff0>listen</span>() {
  <span style=color:red>let</span> socket_address: SocketAddrV4 = SocketAddrV4::new(Ipv4Addr::new(<span style=color:#f60>0</span>, <span style=color:#f60>0</span>, <span style=color:#f60>0</span>, <span style=color:#f60>0</span>), <span style=color:#f60>9778</span>);
  <span style=color:red>let</span> bind_addr = Ipv4Addr::new(<span style=color:#f60>0</span>, <span style=color:#f60>0</span>, <span style=color:#f60>0</span>, <span style=color:#f60>0</span>);
  <span style=color:red>let</span> socket = UdpSocket::bind(socket_address)?;
  println!(<span style=color:#87ceeb>&#34;Listening on: {}&#34;</span>, socket.local_addr().unwrap());
  socket.join_multicast_v4(&amp;MULTI_CAST_ADDR, &amp;bind_addr)?;
}

<span style=color:red>pub</span> <span style=color:red>fn</span> <span style=color:#ff0>cast</span>() -&gt; Result&lt;()&gt; {
  <span style=color:red>let</span> socket_address: SocketAddrV4 = SocketAddrV4::new(Ipv4Addr::new(<span style=color:#f60>0</span>, <span style=color:#f60>0</span>, <span style=color:#f60>0</span>, <span style=color:#f60>0</span>), <span style=color:#f60>0</span>);
  <span style=color:red>let</span> socket = UdpSocket::bind(socket_address)?;
  socket.connect(SocketAddrV4::new(MULTI_CAST_ADDR, <span style=color:#f60>9778</span>))?;
  <span style=color:#0f0>// Don&#39;t send messages to yourself.
</span><span style=color:#0f0></span>  <span style=color:#0f0>// In this case self discovery is for human developers, not machines.
</span><span style=color:#0f0></span>  socket.set_multicast_loop_v4(<span style=color:red>false</span>)?;
  <span style=color:red>let</span> data = String::from(<span style=color:#87ceeb>&#34;{\&#34;username\&#34;: \&#34;test\&#34;}&#34;</span>)
   <span style=color:red>loop</span> {
    socket.send(data.as_bytes())?;
    thread::sleep(time::Duration::from_secs(<span style=color:#f60>2</span>));
  }
  Ok(())
}

<span style=color:red>fn</span> <span style=color:#ff0>main</span>() {
  thread::spawn(||{
      listen();
    });
  cast();
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:red>import</span> dgram from <span style=color:#87ceeb>&#34;dgram&#34;</span>;
<span style=color:red>import</span> cluster from <span style=color:#87ceeb>&#34;cluster&#34;</span>;

<span style=color:red>const</span> MULTI_CAST_ADDR = <span style=color:#87ceeb>&#34;224.0.0.1&#34;</span>;

<span style=color:red>function</span> listen() {
  <span style=color:red>const</span> server = dgram.createSocket(<span style=color:#87ceeb>&#34;udp4&#34;</span>);
  server.on(<span style=color:#87ceeb>&#34;message&#34;</span>, (msg, rinfo) =&gt; {
    console.log(<span style=color:#87ceeb>`server got: </span><span style=color:#87ceeb>${</span>msg<span style=color:#87ceeb>}</span><span style=color:#87ceeb> from </span><span style=color:#87ceeb>${</span>rinfo.address<span style=color:#87ceeb>}</span><span style=color:#87ceeb>:</span><span style=color:#87ceeb>${</span>rinfo.port<span style=color:#87ceeb>}</span><span style=color:#87ceeb>`</span>);
  });
  server.bind(<span style=color:#f60>9778</span>, (a) =&gt; {
    server.addMembership(MULTI_CAST_ADDR);
  });
  server.on(<span style=color:#87ceeb>&#34;listening&#34;</span>, () =&gt; {
    <span style=color:red>const</span> address = server.address();
    console.log(<span style=color:#87ceeb>`Listening on: </span><span style=color:#87ceeb>${</span>address.address<span style=color:#87ceeb>}</span><span style=color:#87ceeb>:</span><span style=color:#87ceeb>${</span>address.port<span style=color:#87ceeb>}</span><span style=color:#87ceeb>`</span>);
  });
}

<span style=color:red>function</span> cast() {
  <span style=color:red>const</span> client = dgram.createSocket(<span style=color:#87ceeb>&#34;udp4&#34;</span>);
  setInterval(() =&gt; {
    <span style=color:red>const</span> message = Buffer.from(<span style=color:#87ceeb>&#34;TEST&#34;</span>);
    client.send(message, <span style=color:#f60>9778</span>, MULTI_CAST_ADDR);
  }, <span style=color:#f60>2000</span>);
}

<span style=color:red>function</span> main() {
  <span style=color:red>if</span> (cluster.isMaster) {
    cluster.fork();
    listen();
  } <span style=color:red>else</span> <span style=color:red>if</span> (cluster.isWorker) {
    cast();
  }
}

main();
</code></pre></div></section></article></main><footer><hr>‚ö°Ô∏è
2021 modified <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></footer></div></body></html>