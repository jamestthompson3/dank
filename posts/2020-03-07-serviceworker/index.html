<!doctype html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>ðŸ‘· Using Service Workers to Cache Content</title><meta name=viewport content="width=device-width,initial-scale=1">
<link rel=canonical href=https://teukka.tech/posts/2020-03-07-serviceworker/><link rel=webmention href=https://webmention.io/teukka.tech/webmention><link rel=pingback href=https://webmention.io/teukka.tech/xmlrpc><link rel=micropub href=http://pub.teukka.tech/micropub/main><meta property="og:url" content="https://teukka.tech/posts/2020-03-07-serviceworker/"><meta property="og:site_name" content="teukka.tech"><meta property="og:title" content="Build a Better Web with Service Workers"><meta property="og:description" content="Make a better web experience with service workers."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-03-07T00:00:00+00:00"><meta property="article:modified_time" content="2020-03-07T00:00:00+00:00"><meta property="article:tag" content="Javascript"><meta property="article:tag" content="Service Worker"><meta property="article:tag" content="Webdev"><meta property="og:image" content="https://images.unsplash.com/photo-1573325743508-f6eef36bb65f?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://images.unsplash.com/photo-1573325743508-f6eef36bb65f?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80"><meta name=twitter:title content="Build a Better Web with Service Workers"><meta name=twitter:description content="Make a better web experience with service workers."><link href=https://teukka.tech/css/fonts.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://teukka.tech/css/main.css><link rel=stylesheet type=text/css media=screen href=https://teukka.tech/css/paginator.css><link rel=stylesheet type=text/css media=screen href=https://teukka.tech/css/hcard.css><link rel=stylesheet type=text/css media=screen href=https://teukka.tech/css/updates.css><link rel=stylesheet type=text/css media=screen href=https://teukka.tech/css/fastsearch.css><link rel=stylesheet type=text/css media=screen href=https://teukka.tech/css/bookmarks.css><link rel=stylesheet type=text/css href=https://teukka.tech/css/dark.css media="(prefers-color-scheme: dark)"><script>window.location.host!=="teukka.tech"&&(window.goatcounter={no_onload:!0})</script></head><body><div class=content><header><div class=main><a class=homepage href=https://teukka.tech/>teukka.tech</a></div><nav><a href=/posts>posts</a>
<a href=/updates>updates</a>
<a href=/photos>photos</a></nav><div id=fastSearch><label for=searchInput style=display:none>search the blog</label>
<input id=searchInput tabindex=0 placeholder="search ðŸ”"><ul id=searchResults></ul></div></header><main><br><br><article class="h-entry post"><div class=title><h1 class=title><a class="p-name u-url" href=https://teukka.tech/posts/2020-03-07-serviceworker/>Build a Better Web with Service Workers</a></h1><div class="dt-published meta">Posted on 2020-03-07</div><a rel=author class="p-author h-card" href=/>taylor thompson</a></div><div class=post-tags><nav class="nav tags"><ul class=tags><li><a class=p-category href=/tags/javascript>javascript</a></li><li><a class=p-category href=/tags/service-worker>service worker</a></li><li><a class=p-category href=/tags/webdev>webdev</a></li></ul></nav></div><section class="body e-content"><h2 id=working-hard-or-hardly-working>Working Hard, or Hardly Working?</h2><p>The Service Worker API is a powerful tool for providing better offline experiences, push notifications, and background syncing for web applications. Like me, you may be familiar with service workers from the role they play in creating Progressive Web Apps (PWAs), or from seeing them registered as part of the build output of <code>create-react-app</code>. While this automatic output from build tools such as <code>create-react-app</code> is very useful in getting started with PWAs, using the Service Worker API is much more beneficial to your application when tailored to your use cases. Let&rsquo;s dive into the Service Worker API to see how it provides a better user experience in some common use cases, starting with caching network responses.</p><p>A great place to start for any Web API is the MDN Page. In the case of the Service Worker API, MDN offers the <a href=https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API>following paragraph</a> as an introduction:</p><blockquote><p>Service workers essentially act as proxy servers that sit between web applications, the browser, and the network (when available). They are intended, among other things, to enable the creation of effective offline experiences, intercept network requests and take appropriate action based on whether the network is available, and update assets residing on the server. They will also allow access to push notifications and background sync APIs.</p></blockquote><p>Since service workers act as a man in the middle between the browser, network, and your application, their potential is huge! However, this means that the potential for abuse is also huge, and to combat this abuse, browsers have built in security measures around the Service Worker API. Some of these security measures are: service workers are <em>only</em> registered over HTTPS or from your <code>localhost</code>, and only registered from the same origin as the current page. Working in Firefox, you enable service workers over HTTP in your developer tools console, and inspect and debug registered service workers in <code>about:debugging</code>.</p><h2 id=cache-money>Cache Money</h2><p>Content Caching is a great starting point for utilizing service workers, and tools like <code>create-react-app</code> implement by default. Caching static assets is one of the first steps in creating a PWA. Let&rsquo;s dive into caching by looking at the code for caching this blog for offline use! If you open up your devloper tools on the <a href=https://teukka.tech>homepage</a> of this blog, you&rsquo;ll find an <code>index.js</code> file that has this content:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:red>function</span> registerSW() {
</span></span><span style=display:flex><span>  <span style=color:red>if</span> (location.hostname === <span style=color:#87ceeb>&#34;localhost&#34;</span>) <span style=color:red>return</span>;
</span></span><span style=display:flex><span>  <span style=color:red>if</span> (<span style=color:#87ceeb>&#34;serviceWorker&#34;</span> <span style=color:red>in</span> navigator) {
</span></span><span style=display:flex><span>    navigator.serviceWorker.register(<span style=color:#87ceeb>&#34;/sw-prod.js&#34;</span>).<span style=color:red>catch</span>((e) =&gt; {
</span></span><span style=display:flex><span>      console.log(<span style=color:#87ceeb>&#34;Registration fail: &#34;</span>, e);
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>registerSW();
</span></span></code></pre></div><p>This is the code for registering the service worker for this site. On its own, it&rsquo;s not very compelling or informative, to really understand what&rsquo;s going on under the hood, we need to take a look at the <code>sw-prod.js</code> file. Inspect this file by opening Firefox&rsquo;s <code>about:debugging</code> in a new tab, selecting the service worker for this domain, and clicking <code>inspect</code> (or if it&rsquo;s not running, clicking <code>run</code>, and then <code>inspect</code>).</p><h3 id=what-to-cache>What to cache</h3><p>Now that you have the service worker code let&rsquo;s break it down:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:red>const</span> CACHE_NAME = <span style=color:#87ceeb>&#34;posts-{someUUID}&#34;</span>;
</span></span><span style=display:flex><span><span style=color:red>const</span> PAGES = [
</span></span><span style=display:flex><span>  <span style=color:#87ceeb>&#34;./ico.png&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#87ceeb>&#34;./pandocoverride.css&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#87ceeb>&#34;./style.css&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#87ceeb>&#34;./space.png&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#87ceeb>&#34;./reset.css&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#87ceeb>&#34;./blog.css&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#87ceeb>&#34;./index.html&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#87ceeb>&#34;./vimloop.html&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#87ceeb>&#34;./luanvim.html&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#87ceeb>&#34;./vimtip-gitlens.html&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#87ceeb>&#34;./frameworkpt2.html&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#87ceeb>&#34;./frameworkpt1.html&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#87ceeb>&#34;./frameworkintro.html&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#87ceeb>&#34;./vimcandothat.html&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#87ceeb>&#34;./datastructures.html&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#87ceeb>&#34;./viiksetjs.html&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#87ceeb>&#34;./proxies.html&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#87ceeb>&#34;./rxjs-recompose.html&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#87ceeb>&#34;./blogheader.js&#34;</span>,
</span></span><span style=display:flex><span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#0f0>// install pages
</span></span></span><span style=display:flex><span><span style=color:#0f0></span>self.addEventListener(<span style=color:#87ceeb>&#34;install&#34;</span>, installWorker);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:red>async</span> <span style=color:red>function</span> installWorker(e) {
</span></span><span style=display:flex><span>  <span style=color:red>await</span> self.skipWaiting();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#0f0>// ...continues below
</span></span></span></code></pre></div><h3 id=service-worker-life-cycle>Service Worker life cycle</h3><p>This snippet handles the installation event, as well assigning a value for the cache name and the pages to be initially cached. The interesting part of this code is the function that gets called on the <code>install</code> event. Installation is the first event in the <a href=https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerState>service worker lifecycle</a>, it gets kicked off by the <code>register</code> function in <code>index.js</code>. In our <code>installWorker</code> function, we call the <code>skipWaiting</code> method on the service worker, which causes the waiting service worker (in this case the one we are trying to install) to become the active service worker. Let&rsquo;s move on to the next section:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>self.addEventListener(<span style=color:#87ceeb>&#34;activate&#34;</span>, activateServiceWorker);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:red>async</span> <span style=color:red>function</span> activateServiceWorker(event) {
</span></span><span style=display:flex><span>  <span style=color:red>await</span> deleteOldCaches();
</span></span><span style=display:flex><span>  <span style=color:red>await</span> installCachedFiles();
</span></span><span style=display:flex><span>  event.waitUntil(clients.claim()); <span style=color:#0f0>// make the current sw the active sw in all cached pages
</span></span></span><span style=display:flex><span><span style=color:#0f0></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:red>async</span> <span style=color:red>function</span> installCachedFiles() {
</span></span><span style=display:flex><span>  <span style=color:red>const</span> cache = <span style=color:red>await</span> caches.open(CACHE_NAME);
</span></span><span style=display:flex><span>  <span style=color:red>return</span> cache.addAll(PAGES);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:red>async</span> <span style=color:red>function</span> deleteOldCaches() {
</span></span><span style=display:flex><span>  <span style=color:red>const</span> keys = <span style=color:red>await</span> caches.keys();
</span></span><span style=display:flex><span>  <span style=color:red>const</span> oldVersions = keys.filter((name) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:red>if</span> (<span style=color:#87ceeb>/^posts-(\w{8}(-\w{4}){3}-\w{12}?)/</span>.test(name)) {
</span></span><span style=display:flex><span>      <span style=color:red>return</span> <span style=color:red>true</span>;
</span></span><span style=display:flex><span>    } <span style=color:red>else</span> {
</span></span><span style=display:flex><span>      <span style=color:red>return</span> <span style=color:red>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>  <span style=color:red>return</span> Promise.all(oldVersions.map((key) =&gt; caches.<span style=color:red>delete</span>(key)));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#0f0>// ...continues below
</span></span></span></code></pre></div><p>After the service worker is installed, it activates, calling the <code>activateServiceWorker</code> function we registered on the <code>activate</code> event. When our service worker is activated, we want to delete the old cache and install the current version of the files denoted in the <code>PAGES</code> array in the new cache. The function, <code>deleteOldCaches</code> gets all of the cache keys (which are the old versions of <code>CACHE_NAME</code>), and checks them to see if they match the format we&rsquo;ve given to our <code>CACHE_NAME</code>. We don&rsquo;t simply clear <em>all</em> the keys in the cache because we may have several service workers running at a time, and clearing their data may have unintended consequences, so this service worker only removes data that it has placed in the cache itself.</p><p>Installing the new versions of the blog posts requires opening a cache with the key of <code>CACHE_NAME</code>, and using the <code>addAll</code> method to specify that we want to add everything in the <code>PAGES</code> array to be added. After deleting old versions of the cache and installing the latest posts, the <code>clients.claim()</code> call allows the current service worker to become the active service worker on all pages in its scope. Wrapping <code>clients.claim()</code> inside of <code>event.waitUntil()</code> is an important step because it prevents the browser from interrupting the claim process which could lead to the service worker becoming active on some pages but not on others within its scope. Let&rsquo;s break down the final section:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>self.addEventListener(<span style=color:#87ceeb>&#34;fetch&#34;</span>, (event) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:red>if</span> (
</span></span><span style=display:flex><span>    event.request.mode === <span style=color:#87ceeb>&#34;navigate&#34;</span> ||
</span></span><span style=display:flex><span>    event.request.destination === <span style=color:#87ceeb>&#34;style&#34;</span> ||
</span></span><span style=display:flex><span>    event.request.destination === <span style=color:#87ceeb>&#34;script&#34;</span> ||
</span></span><span style=display:flex><span>    event.request.destination === <span style=color:#87ceeb>&#34;image&#34;</span>
</span></span><span style=display:flex><span>  ) {
</span></span><span style=display:flex><span>    event.respondWith(cacheResponse(event.request, event));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:red>async</span> <span style=color:red>function</span> cacheResponse(request, event) {
</span></span><span style=display:flex><span>  <span style=color:red>const</span> cache = <span style=color:red>await</span> caches.open(CACHE_NAME);
</span></span><span style=display:flex><span>  <span style=color:red>const</span> match = <span style=color:red>await</span> cache.match(request.url);
</span></span><span style=display:flex><span>  <span style=color:red>if</span> (match) {
</span></span><span style=display:flex><span>    <span style=color:red>return</span> match;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#0f0>// Create promises for both the network response,
</span></span></span><span style=display:flex><span><span style=color:#0f0></span>  <span style=color:#0f0>// and a copy of the response that can be used in the cache.
</span></span></span><span style=display:flex><span><span style=color:#0f0></span>  <span style=color:red>const</span> fetchResponseP = fetch(request);
</span></span><span style=display:flex><span>  <span style=color:red>const</span> fetchResponseCloneP = fetchResponseP.then((r) =&gt; r.clone());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  event.waitUntil(
</span></span><span style=display:flex><span>    (<span style=color:red>async</span> <span style=color:red>function</span> () {
</span></span><span style=display:flex><span>      <span style=color:red>await</span> cache.put(request, <span style=color:red>await</span> fetchResponseCloneP);
</span></span><span style=display:flex><span>    })()
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:red>return</span> fetchResponseP;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=going-to-the-network>Going to the network</h3><p>In this segment of the service worker code, we are adding an event listener for <code>fetch</code> events and responding with a cached response under certain conditions. The conditions we are checking before responding with cached response are: if the request is a navigation event (loading this blog post in your browser for example), or if the browser requests additional resources like CSS, Javascript, or images. To illustrate this flow, we&rsquo;ll take a look at two different resources requested by this website, <code>vimtip-gitlens.html</code> and <code>bb8_1.svg</code>.</p><p>Since <code>vimtip-gitlens.html</code> is specified in the <code>PAGES</code> array we cached on service worker activation, we&rsquo;ll look at it first. When you navigate to <a href=https://teukka.tech/vimtip-gitlens.html>the post</a>, the <code>event.respondWith</code> function is executed with the value from <code>cacheResponse</code> being evaluated. Using <code>event.respondWith</code> tells the service worker to intercept the request and respond with the argument passed to this function. Let&rsquo;s step through the <code>cacheResponse</code> function: we first open the current cache (as denoted with the <code>CACHE_NAME</code>) and check to see if there are any entries for the URL of the incoming request. If we&rsquo;ve cached this URL before, we return the cached response&ndash;avoiding a network call. If the service worker can&rsquo;t find the URL from its cache, then makes a network request and places the response into the cache while returning the <em>Promise</em> containing the response back to our main application. Putting the response in the cache is wrapped inside <code>event.waitUntil</code> to ensure that the browser does not interrupt the service worker while updating.</p><h3 id=wrapping-up>Wrapping up</h3><p>The final step in this example is making sure that the service worker always reflects the most up to date content. This means that every time we make a change to one of our cached assets, we update the <code>CACHE_NAME</code> in the service worker. For this blog, I created a bash script that helps ensure I don&rsquo;t forget to update my service worker cache:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#e5e5e5>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#e5e5e5></span>
</span></span><span style=display:flex><span><span style=color:#eedd82>UUID</span>=<span style=color:red>$(</span>cat /proc/sys/kernel/random/uuid<span style=color:red>)</span>
</span></span><span style=display:flex><span>rm -f sw-prod.js
</span></span><span style=display:flex><span>cp sw.js sw-prod.js
</span></span><span style=display:flex><span>sed -i <span style=color:#87ceeb>&#34;s/%VERSION%/</span><span style=color:#eedd82>$UUID</span><span style=color:#87ceeb>/g&#34;</span> sw-prod.js
</span></span><span style=display:flex><span>echo <span style=color:#87ceeb>&#34;Built version: </span><span style=color:#87ceeb>${</span><span style=color:#eedd82>UUID</span><span style=color:#87ceeb>}</span><span style=color:#87ceeb>&#34;</span>
</span></span></code></pre></div><p>I use the <code>uuid</code> functionality built into Linux to generate a unique name for my cache, then I copy my service worker code with a placeholder for <code>CACHE_NAME</code> to the <code>sw-prod.js</code> file. The final step is to replace my placeholder cache name with the unique identifier I generated.</p><p>Caching static files is a great way to start using the Service Worker API, and offers your users a better offline experience. Stay tuned for more service worker tips!</p></section></article></main><h3>See Also</h3><ul><li><a href=/posts/2020-02-01-proxies/>A Brief Look at Javascript Proxies</a></li><li><a href=/posts/2019-10-01-byoff-part-2/>Build Your Own Frontend Framework Part 2, Data Fetching</a></li><li><a href=/posts/2019-09-15-byoff-part-1/>Build Your Own Frontend Framework Part 1</a></li><li><a href=/posts/2019-09-09-build-your-own-frontend-framework/>Build Your Own Frontend Framework, Introduction</a></li></ul><div class=webmention><h3>Mentioned around the web</h3></div><script src=/js/fuse.js></script><script src=/js/fastsearch.js></script><footer><hr><div class=h-card><a class=pic-link href=https://en.wikipedia.org/wiki/Pygmy_slow_loris><img class=u-photo src=https://teukka.tech/Nycticebus_pygmaeus_002.webp alt="pygmy
    slow loris, an endangered and beautiful creature"></a><div class=info><span class=p-name>Taylor Thompson</span>
<a class=u-email href=mailto:taylor@teukka.tech>taylor@teukka.tech</a>
<a rel=me class=u-url>https://teukka.tech</a>
<span class=p-note>eternally curious person</span></div></div><small>&copy; taylor thompson</small>
<img src=https://teukka.tech//images/sigil_dark.png alt=sigil style=border:none;width:20px;height:20px></footer><script data-goatcounter=https://teukka_tech.goatcounter.com/count async src=//gc.zgo.at/count.js></script></div></body></html>