<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Es6 on teukka.tech</title><link>https://teukka.tech/tags/es6/</link><description>Recent content in Es6 on teukka.tech</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sat, 01 Feb 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://teukka.tech/tags/es6/index.xml" rel="self" type="application/rss+xml"/><item><title>A Brief Look at Javascript Proxies</title><link>https://teukka.tech/posts/2020-02-01-proxies/</link><pubDate>Sat, 01 Feb 2020 00:00:00 +0000</pubDate><guid>https://teukka.tech/posts/2020-02-01-proxies/</guid><description>&lt;h2 id="proxies">Proxies&lt;/h2>
&lt;p>Javascript Proxies are a powerful concept in ES6. They give developers more control over JS objects, paving the way for declarative API design. I am going to show some examples of how use proxies to extend the functionality of traditional Javascript objects and why they are useful in understanding the flow of data inside your programs.&lt;/p>
&lt;h2 id="microservice-client">Microservice Client&lt;/h2>
&lt;p>The first example comes from a request management client that uses a JSON schema to validate incoming requests and route them to other services. The code for its implementation is &lt;a href="https://github.com/jamestthompson3/micro-manager">here&lt;/a>. Proxies are valuable in this context since our request client&amp;rsquo;s API reflects our schema, thus allowing the schema to serve as both validation and documentation. Another advantage to schema driven API definitions is that automated tools are able to generate and update the schemas based on microservice API docs, minimizing the work needed to stay in sync with other services to which we are making requests.&lt;/p></description></item></channel></rss>