<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Webdev on teukka.tech</title><link>https://teukka.tech/tags/webdev/</link><description>Recent content in Webdev on teukka.tech</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sat, 13 Mar 2021 12:23:44 +0000</lastBuildDate><atom:link href="https://teukka.tech/tags/webdev/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://teukka.tech/updates/44624/</link><pubDate>Sat, 13 Mar 2021 12:23:44 +0000</pubDate><guid>https://teukka.tech/updates/44624/</guid><description>&lt;p>I&amp;rsquo;ve enjoyed using Hugo to build out my personal website. It makes it so easy to just focus on the fun stuff without worrying about all the tooling you need to generate really great static sites. It&amp;rsquo;s also super fast!&lt;/p></description></item><item><title>Javascript Quick Tip -- Browser Notifications</title><link>https://teukka.tech/posts/2020-05-16-notifications/</link><pubDate>Sat, 16 May 2020 00:00:00 +0000</pubDate><guid>https://teukka.tech/posts/2020-05-16-notifications/</guid><description>&lt;h2 id="let-em-know">Let &amp;lsquo;Em Know&lt;/h2>
&lt;p>While notifications are one of the browser features that are often abused and lead to obnoxious spam, there are still use cases where notifications enhance the experience of your web application. Modern browsers (with the exception of iOS Safari), support two types of notifications: &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Push_API">push&lt;/a>, and &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Notifications_API">web&lt;/a>. This post discusses &lt;em>only&lt;/em> web notifications, since they do not require registration on a server, or the use of a service worker (although they can be used with both). After a short intro on how to set up web notifications, we&amp;rsquo;ll dive into an example where web notifications are a useful addition to your web app.&lt;/p></description></item><item><title>Build a Better Web with Service Workers</title><link>https://teukka.tech/posts/2020-03-07-serviceworker/</link><pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate><guid>https://teukka.tech/posts/2020-03-07-serviceworker/</guid><description>&lt;h2 id="working-hard-or-hardly-working">Working Hard, or Hardly Working?&lt;/h2>
&lt;p>The Service Worker API is a powerful tool for providing better offline experiences, push notifications, and background syncing for web applications. Like me, you may be familiar with service workers from the role they play in creating Progressive Web Apps (PWAs), or from seeing them registered as part of the build output of &lt;code>create-react-app&lt;/code>. While this automatic output from build tools such as &lt;code>create-react-app&lt;/code> is very useful in getting started with PWAs, using the Service Worker API is much more beneficial to your application when tailored to your use cases. Let&amp;rsquo;s dive into the Service Worker API to see how it provides a better user experience in some common use cases, starting with caching network responses.&lt;/p></description></item><item><title>A Brief Look at Javascript Proxies</title><link>https://teukka.tech/posts/2020-02-01-proxies/</link><pubDate>Sat, 01 Feb 2020 00:00:00 +0000</pubDate><guid>https://teukka.tech/posts/2020-02-01-proxies/</guid><description>&lt;h2 id="proxies">Proxies&lt;/h2>
&lt;p>Javascript Proxies are a powerful concept in ES6. They give developers more control over JS objects, paving the way for declarative API design. I am going to show some examples of how use proxies to extend the functionality of traditional Javascript objects and why they are useful in understanding the flow of data inside your programs.&lt;/p>
&lt;h2 id="microservice-client">Microservice Client&lt;/h2>
&lt;p>The first example comes from a request management client that uses a JSON schema to validate incoming requests and route them to other services. The code for its implementation is &lt;a href="https://github.com/jamestthompson3/micro-manager">here&lt;/a>. Proxies are valuable in this context since our request client&amp;rsquo;s API reflects our schema, thus allowing the schema to serve as both validation and documentation. Another advantage to schema driven API definitions is that automated tools are able to generate and update the schemas based on microservice API docs, minimizing the work needed to stay in sync with other services to which we are making requests.&lt;/p></description></item><item><title>Build Your Own Frontend Framework Part 2, Data Fetching</title><link>https://teukka.tech/posts/2019-10-01-byoff-part-2/</link><pubDate>Thu, 10 Oct 2019 00:00:00 +0000</pubDate><guid>https://teukka.tech/posts/2019-10-01-byoff-part-2/</guid><description>&lt;h2 id="part-two-data-fetching-on-mount">Part Two, Data Fetching on Mount&lt;/h2>
&lt;p>Asynchronous actions are essential in any modern web application. The ability to fetch data from some service and display it to users is an important part of building a framework to support these applications. In order for our components to do this, we need to refactor. Our component calls &lt;code>mount&lt;/code> when we want to render it on the page, but this function only serves to attach styles and event handlers to the component, not fetch data asynchronously. To accommodate actions taken after our component has been defined, but before it is actually rendered, we need a new method: &lt;code>componentDidMount&lt;/code>.&lt;/p></description></item><item><title>Build Your Own Frontend Framework Part 1</title><link>https://teukka.tech/posts/2019-09-15-byoff-part-1/</link><pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate><guid>https://teukka.tech/posts/2019-09-15-byoff-part-1/</guid><description>&lt;h2 id="part-one-basic-component">Part One, Basic Component&lt;/h2>
&lt;p>Components will be the basic building blocks of our frontend framework. Components will allow modular composition and encapsulation.
The first component implementation will be rather naive, but that&amp;rsquo;s alright since its implementation will evolve over time.
Let&amp;rsquo;s start with creating a &lt;code>Component&lt;/code> class:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">COOL_COMPONENT&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Symbol&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;component&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Component&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">constructor&lt;/span>(&lt;span style="color:#a6e22e">element&lt;/span>, &lt;span style="color:#a6e22e">args&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {}) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">$$typeof&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">COOL_COMPONENT&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">el&lt;/span> &lt;span style="color:#f92672">=&lt;/span> document.&lt;span style="color:#a6e22e">createElement&lt;/span>(&lt;span style="color:#a6e22e">element&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">args&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">args&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Breaking this down:&lt;/p>
&lt;p>&lt;code>const COOL_COMPONENT = Symbol('component')&lt;/code>&lt;/p>
&lt;p>This creates a unique representation for our component type, and will help identify component instances as they get passed around our framework.
The component takes an element type and some arguments which we&amp;rsquo;ll handle a bit later. The constructor also creates a new element which we&amp;rsquo;ll mount on the DOM with a &lt;code>mount&lt;/code> function.
Now that we have a very basic component, we need a way to mount it to the DOM. Starting with a naive implementation, we can do something like this:&lt;/p></description></item></channel></rss>