<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>lua on teukka.tech</title><link>https://teukka.tech/tags/lua/</link><description>Recent content in lua on teukka.tech</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>taylor@teukka.tech (taylor thompson)</managingEditor><webMaster>taylor@teukka.tech (taylor thompson)</webMaster><lastBuildDate>Wed, 31 Mar 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://teukka.tech/tags/lua/index.xml" rel="self" type="application/rss+xml"/><item><title>(Nvim) Lua for Javascripters: Module Exports</title><link>https://teukka.tech/posts/js-to-lua-modules/</link><pubDate>Wed, 31 Mar 2021 00:00:00 +0000</pubDate><author>taylor@teukka.tech (taylor thompson)</author><guid>https://teukka.tech/posts/js-to-lua-modules/</guid><description>Goals This aims to be quick reference guide on lua module exports compared to JavaScript module exports.
Task We want to export a series of module scoped functions in both JavaScript and Lua. This guide also show side by side comparisons on writing a file to a specific directory and deleting a file from the same directory.
In this quick tip, we will use CommonJS as the format for the JavaScript modules since it more closely resembles Lua modules in its construction.</description></item><item><title/><link>https://teukka.tech/updates/39029/</link><pubDate>Fri, 19 Mar 2021 10:50:29 +0000</pubDate><author>taylor@teukka.tech (taylor thompson)</author><guid>https://teukka.tech/updates/39029/</guid><description>Wishing there was a way to compile &amp;ldquo;self contained&amp;rdquo; binaries with luvit. It seems that you still need to have libs like luvit in your path to run the binary when you compile your projects.</description></item><item><title>(Nvim) Lua for Javascripters: Spawning Processes</title><link>https://teukka.tech/posts/js-to-lua/</link><pubDate>Tue, 16 Mar 2021 00:00:00 +0000</pubDate><author>taylor@teukka.tech (taylor thompson)</author><guid>https://teukka.tech/posts/js-to-lua/</guid><description>Goals This should be a quick reference guide for those familiar with NodeJS on how to execute the same async tasks in Lua using luv. This is aimed towards use cases inside Neovim, but is not limited to those cases.
Task We want to spawn a child task to convert a markdown document into HTML using pandoc. This could be used as part of a publishing flow for a blog, for writing notes, or for implementing a markdown previewer.</description></item><item><title/><link>https://teukka.tech/updates/37805/</link><pubDate>Mon, 15 Mar 2021 10:30:05 +0000</pubDate><author>taylor@teukka.tech (taylor thompson)</author><guid>https://teukka.tech/updates/37805/</guid><description>Wondering if there are any guides out there for using lua for build scripting. Seems like it would be faster than spinning up a nodevm, easier to read and reason about that monster bash scripts, and less maintenance than a project written in something like Go or Rust.</description></item><item><title>Neovim Tip, GitLens</title><link>https://teukka.tech/posts/2020-01-28-vimtip-gitlens/</link><pubDate>Tue, 28 Jan 2020 00:00:00 +0000</pubDate><author>taylor@teukka.tech (taylor thompson)</author><guid>https://teukka.tech/posts/2020-01-28-vimtip-gitlens/</guid><description>Intro GitLens is a VSCode plugin that, among other things, allows you to see the time, commit author, and commit message of the current line. With a little help from to the neovim api and our shell, it we can recreate this functionality in a few lines of lua code.
The Code -- in utils.lua local M = {} local api = vim.api function M.blameVirtText() local ft = vim.fn.expand(&amp;#39;%:h:t&amp;#39;) -- get the current file extension if ft == &amp;#39;&amp;#39; then -- if we are in a scratch buffer or unknown filetype return end if ft == &amp;#39;bin&amp;#39; then -- if we are in nvim&amp;#39;s terminal window return end api.</description></item><item><title>Using LibUV in Neovim</title><link>https://teukka.tech/posts/2020-01-07-vimloop/</link><pubDate>Tue, 07 Jan 2020 00:00:00 +0000</pubDate><author>taylor@teukka.tech (taylor thompson)</author><guid>https://teukka.tech/posts/2020-01-07-vimloop/</guid><description>Off The Main Loop: Async Actions within Neovim Neovim embeds the libuv library in the editor and exposes lua (and to some extent vimscript through the jobstart function) bindings for interacting with the library&amp;rsquo;s API. This allows actions in the editor to happen asynchronously, keeping the main editor loop clear for user input. What this means practically for users is that actions which take a long time such as grepping through large projects, generating ctags, or linting can now be done in the background without blocking the user&amp;rsquo;s ability to keep editing text.</description></item><item><title>From init.vim to init.lua</title><link>https://teukka.tech/posts/2019-12-19-luanvim/</link><pubDate>Mon, 16 Dec 2019 00:00:00 +0000</pubDate><author>taylor@teukka.tech (taylor thompson)</author><guid>https://teukka.tech/posts/2019-12-19-luanvim/</guid><description>Why Lua? Neovim has an embedded lua 5.1 runtime which is used to create faster and more powerful extensions of your favorite editor. In the Neovim charter, it lists one of its goals as developing a first-class lua scripting alternative to VimL. One of the reasons for doing this is that VimL is a slow interpreted language with almost no optimizations. Much of the time spent in vim startup and in actions from plugins that can block the main loop in the editor is in parsing and executing vimscript.</description></item></channel></rss>